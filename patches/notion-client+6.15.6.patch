diff --git a/node_modules/notion-client/build/index.js b/node_modules/notion-client/build/index.js
index 625be1d..e01a305 100644
--- a/node_modules/notion-client/build/index.js
+++ b/node_modules/notion-client/build/index.js
@@ -1,2 +1,2 @@
-import z from"got";import{getBlockCollectionId as Q,getPageContentBlockIds as O,parsePageId as $,uuidToId as Y}from"notion-utils";import G from"p-map";var E=class{constructor({apiBaseUrl:r="https://www.notion.so/api/v3",authToken:n,activeUser:e,userTimeZone:a="America/New_York"}={}){this._apiBaseUrl=r,this._authToken=n,this._activeUser=e,this._userTimeZone=a}async getPage(r,{concurrency:n=3,fetchMissingBlocks:e=!0,fetchCollections:a=!0,signFileUrls:o=!0,chunkLimit:s=100,chunkNumber:h=0,gotOptions:p}={}){let y=await this.getPageRaw(r,{chunkLimit:s,chunkNumber:h,gotOptions:p}),t=y==null?void 0:y.recordMap;if(!(t!=null&&t.block))throw new Error(`Notion page not found "${Y(r)}"`);if(t.collection=t.collection??{},t.collection_view=t.collection_view??{},t.notion_user=t.notion_user??{},t.collection_query={},t.signed_urls={},e)for(;;){let d=O(t).filter(i=>!t.block[i]);if(!d.length)break;let c=await this.getBlocks(d,p).then(i=>i.recordMap.block);t.block={...t.block,...c}}let _=O(t);if(a){let d=_.flatMap(c=>{var m;let i=t.block[c].value,g=i&&(i.type==="collection_view"||i.type==="collection_view_page")&&Q(i,t);return g?(m=i.view_ids)==null?void 0:m.map(b=>({collectionId:g,collectionViewId:b})):[]});await G(d,async c=>{var b,k;let{collectionId:i,collectionViewId:g}=c,m=(b=t.collection_view[g])==null?void 0:b.value;try{let l=await this.getCollectionData(i,g,m,{gotOptions:p});t.block={...t.block,...l.recordMap.block},t.collection={...t.collection,...l.recordMap.collection},t.collection_view={...t.collection_view,...l.recordMap.collection_view},t.notion_user={...t.notion_user,...l.recordMap.notion_user},t.collection_query[i]={...t.collection_query[i],[g]:(k=l.result)==null?void 0:k.reducerResults}}catch(l){console.warn("NotionAPI collectionQuery error",r,l.message),console.error(l)}},{concurrency:n})}return o&&await this.addSignedUrls({recordMap:t,contentBlockIds:_,gotOptions:p}),t}async addSignedUrls({recordMap:r,contentBlockIds:n,gotOptions:e={}}){r.signed_urls={},n||(n=O(r));let a=n.flatMap(o=>{var h,p,y,t,_,d;let s=(h=r.block[o])==null?void 0:h.value;if(s&&(s.type==="pdf"||s.type==="audio"||s.type==="image"&&((p=s.file_ids)==null?void 0:p.length)||s.type==="video"||s.type==="file"||s.type==="page")){let c=s.type==="page"?(y=s.format)==null?void 0:y.page_cover:(d=(_=(t=s.properties)==null?void 0:t.source)==null?void 0:_[0])==null?void 0:d[0];if(c)return c.includes("secure.notion-static.com")?{permissionRecord:{table:"block",id:s.id},url:c}:[]}return[]});if(a.length>0)try{let{signedUrls:o}=await this.getSignedFileUrls(a,e);if(o.length===a.length)for(let s=0;s<a.length;++s){let h=a[s],p=o[s];r.signed_urls[h.permissionRecord.id]=p}}catch(o){console.warn("NotionAPI getSignedfileUrls error",o)}}async getPageRaw(r,{gotOptions:n,chunkLimit:e=100,chunkNumber:a=0}={}){let o=$(r);if(!o)throw new Error(`invalid notion pageId "${r}"`);let s={pageId:o,limit:e,chunkNumber:a,cursor:{stack:[]},verticalColumns:!1};return this.fetch({endpoint:"loadPageChunk",body:s,gotOptions:n})}async getCollectionData(r,n,e,{limit:a=9999,searchQuery:o="",userTimeZone:s=this._userTimeZone,loadContentCover:h=!0,gotOptions:p}={}){var i,g,m,b,k,l,q,T,I,N,C,P;let y=e==null?void 0:e.type,t=y==="board",_=t?(i=e==null?void 0:e.format)==null?void 0:i.board_columns_by:(g=e==null?void 0:e.format)==null?void 0:g.collection_group_by,d=[];(m=e==null?void 0:e.format)!=null&&m.property_filters&&(d=(b=e.format)==null?void 0:b.property_filters.map(f=>{var B,R;return{filter:(B=f==null?void 0:f.filter)==null?void 0:B.filter,property:(R=f==null?void 0:f.filter)==null?void 0:R.property}})),(l=(k=e==null?void 0:e.query2)==null?void 0:k.filter)!=null&&l.filters&&d.push(...e.query2.filter.filters);let c={type:"reducer",reducers:{collection_group_results:{type:"results",limit:a,loadContentCover:h}},sort:[],...e==null?void 0:e.query2,filter:{filters:d,operator:"and"},searchQuery:o,userTimeZone:s};if(_){let f=((q=e==null?void 0:e.format)==null?void 0:q.board_columns)||((T=e==null?void 0:e.format)==null?void 0:T.collection_groups)||[],B=[t?"board":"group_aggregation","results"],R={checkbox:"checkbox_is",url:"string_starts_with",text:"string_starts_with",select:"enum_is",multi_select:"enum_contains",created_time:"date_is_within",undefined:"is_empty"},x={};for(let v of f){let{property:D,value:{value:u,type:J}}=v;for(let S of B){let F=S==="results"?{type:S,limit:a}:{type:"aggregation",aggregation:{aggregator:"count"}},U=typeof u>"u",M=u==null?void 0:u.range,A=U?"uncategorized":M?((I=u.range)==null?void 0:I.start_date)||((N=u.range)==null?void 0:N.end_date):(u==null?void 0:u.value)||u,Z=!U&&(M||(u==null?void 0:u.value)||u);x[`${S}:${J}:${A}`]={...F,filter:{operator:"and",filters:[{property:D,filter:{operator:U?"is_empty":R[J],...!U&&{value:{type:"exact",value:Z}}}}]}}}}let L=t?"board_columns":`${y}_groups`;c={type:"reducer",reducers:{[L]:{type:"groups",groupBy:_,...((C=e==null?void 0:e.query2)==null?void 0:C.filter)&&{filter:(P=e==null?void 0:e.query2)==null?void 0:P.filter},groupSortPreference:f.map(v=>v==null?void 0:v.value),limit:a},...x},...e==null?void 0:e.query2,searchQuery:o,userTimeZone:s,filter:{filters:d,operator:"and"}}}return this.fetch({endpoint:"queryCollection",body:{collection:{id:r},collectionView:{id:n},loader:c},gotOptions:p})}async getUsers(r,n){return this.fetch({endpoint:"getRecordValues",body:{requests:r.map(e=>({id:e,table:"notion_user"}))},gotOptions:n})}async getBlocks(r,n){return this.fetch({endpoint:"syncRecordValues",body:{requests:r.map(e=>({table:"block",id:e,version:-1}))},gotOptions:n})}async getSignedFileUrls(r,n){return this.fetch({endpoint:"getSignedFileUrls",body:{urls:r},gotOptions:n})}async search(r,n){let e={type:"BlocksInAncestor",source:"quick_find_public",ancestorId:$(r.ancestorId),sort:"Relevance",limit:r.limit||20,query:r.query,filters:{isDeletedOnly:!1,isNavigableOnly:!1,excludeTemplates:!0,requireEditPermissions:!1,ancestors:[],createdBy:[],editedBy:[],lastEditedTime:{},createdTime:{},...r.filters}};return this.fetch({endpoint:"search",body:e,gotOptions:n})}async fetch({endpoint:r,body:n,gotOptions:e,headers:a}){let o={...a,...e==null?void 0:e.headers,"Content-Type":"application/json"};this._authToken&&(o.cookie=`token_v2=${this._authToken}`),this._activeUser&&(o["x-notion-active-user-header"]=this._activeUser);let s=`${this._apiBaseUrl}/${r}`;return z.post(s,{...e,json:n,headers:o}).json()}};export{E as NotionAPI};
+import z from"got";import{getBlockCollectionId as Q,getPageContentBlockIds as O,parsePageId as $,uuidToId as Y}from"notion-utils";import G from"p-map";var E=class{constructor({apiBaseUrl:r="https://www.notion.so/api/v3",authToken:n,activeUser:e,userTimeZone:a="America/New_York"}={}){this._apiBaseUrl=r,this._authToken=n,this._activeUser=e,this._userTimeZone=a}async getPage(r,{concurrency:n=3,fetchMissingBlocks:e=!0,fetchCollections:a=!0,signFileUrls:o=!0,chunkLimit:s=100,chunkNumber:h=0,gotOptions:p}={}){let y=await this.getPageRaw(r,{chunkLimit:s,chunkNumber:h,gotOptions:p}),t=y==null?void 0:y.recordMap;if(!(t!=null&&t.block))throw new Error(`Notion page not found "${Y(r)}"`);if(t.collection=t.collection??{},t.collection_view=t.collection_view??{},t.notion_user=t.notion_user??{},t.collection_query={},t.signed_urls={},e)for(;;){let d=O(t).filter(i=>!t.block[i]);if(!d.length)break;let c=await this.getBlocks(d,p).then(i=>i.recordMap.block);t.block={...t.block,...c}}let _=O(t);if(a){let d=_.flatMap(c=>{var m;let i=t.block[c].value,g=i&&(i.type==="collection_view"||i.type==="collection_view_page")&&Q(i,t);return g?(m=i.view_ids)==null?void 0:m.map(b=>({collectionId:g,collectionViewId:b})):[]});await G(d,async c=>{var b,k;let{collectionId:i,collectionViewId:g}=c,m=(b=t.collection_view[g])==null?void 0:b.value;try{let l=await this.getCollectionData(i,g,m,{gotOptions:p});t.block={...t.block,...l.recordMap.block},t.collection={...t.collection,...l.recordMap.collection},t.collection_view={...t.collection_view,...l.recordMap.collection_view},t.notion_user={...t.notion_user,...l.recordMap.notion_user},t.collection_query[i]={...t.collection_query[i],[g]:(k=l.result)==null?void 0:k.reducerResults}}catch(l){console.warn("NotionAPI collectionQuery error",r,l.message),console.error(l)}},{concurrency:n})}return o&&await this.addSignedUrls({recordMap:t,contentBlockIds:_,gotOptions:p}),t}async addSignedUrls({recordMap:r,contentBlockIds:n,gotOptions:e={}}){r.signed_urls={},n||(n=O(r));let a=n.flatMap(o=>{var h,p,y,t,_,d;let s=(h=r.block[o])==null?void 0:h.value;if(s&&(s.type==="pdf"||s.type==="audio"||s.type==="image"&&((p=s.file_ids)==null?void 0:p.length)||s.type==="video"||s.type==="file"||s.type==="page")){let c=s.type==="page"?(y=s.format)==null?void 0:y.page_cover:(d=(_=(t=s.properties)==null?void 0:t.source)==null?void 0:_[0])==null?void 0:d[0];if(c)return c.includes("secure.notion-static.com")?{permissionRecord:{table:"block",id:s.id},url:c}:[]}return[]});if(a.length>0)try{let{signedUrls:o}=await this.getSignedFileUrls(a,e);if(o.length===a.length)for(let s=0;s<a.length;++s){let h=a[s],p=o[s];r.signed_urls[h.permissionRecord.id]=p}}catch(o){console.warn("NotionAPI getSignedfileUrls error",o)}}async getPageRaw(r,{gotOptions:n,chunkLimit:e=100,chunkNumber:a=0}={}){let o=$(r);if(!o)throw new Error(`invalid notion pageId "${r}"`);let s={pageId:o,limit:e,chunkNumber:a,cursor:{stack:[]},verticalColumns:!1};return this.fetch({endpoint:"loadPageChunk",body:s,gotOptions:n})}async getCollectionData(r,n,e,{limit:a=9999,searchQuery:o="",userTimeZone:s=this._userTimeZone,loadContentCover:h=!0,gotOptions:p}={}){var i,g,m,b,k,l,q,T,I,N,C,P;let y=e==null?void 0:e.type,t=y==="board",_=t?(i=e==null?void 0:e.format)==null?void 0:i.board_columns_by:(g=e==null?void 0:e.format)==null?void 0:g.collection_group_by,d=[];(m=e==null?void 0:e.format)!=null&&m.property_filters&&(d=(b=e.format)==null?void 0:b.property_filters.map(f=>{var B,R;return{filter:(B=f==null?void 0:f.filter)==null?void 0:B.filter,property:(R=f==null?void 0:f.filter)==null?void 0:R.property}})),(l=(k=e==null?void 0:e.query2)==null?void 0:k.filter)!=null&&l.filters&&d.push(...e.query2.filter.filters);let c={type:"reducer",reducers:{collection_group_results:{type:"results",limit:a,loadContentCover:h}},sort:[],...e==null?void 0:e.query2,filter:{filters:d,operator:"and"},searchQuery:o,userTimeZone:s};if(_){let f=((q=e==null?void 0:e.format)==null?void 0:q.board_columns)||((T=e==null?void 0:e.format)==null?void 0:T.collection_groups)||[],B=[t?"board":"group_aggregation","results"],R={checkbox:"checkbox_is",url:"string_starts_with",text:"string_starts_with",select:"enum_is",multi_select:"enum_contains",created_time:"date_is_within",undefined:"is_empty"},x={};for(let v of f){let{property:D,value:{value:u,type:J}}=v;for(let S of B){let F=S==="results"?{type:S,limit:a}:{type:"aggregation",aggregation:{aggregator:"count"}},U=typeof u>"u",M=u==null?void 0:u.range,A=U?"uncategorized":M?((I=u.range)==null?void 0:I.start_date)||((N=u.range)==null?void 0:N.end_date):(u==null?void 0:u.value)||u,Z=!U&&(M||(u==null?void 0:u.value)||u);x[`${S}:${J}:${A}`]={...F,filter:{operator:"and",filters:[{property:D,filter:{operator:U?"is_empty":R[J],...!U&&{value:{type:"exact",value:Z}}}}]}}}}let L=t?"board_columns":`${y}_groups`;c={type:"reducer",reducers:{[L]:{type:"groups",groupBy:_,...((C=e==null?void 0:e.query2)==null?void 0:C.filter)&&{filter:(P=e==null?void 0:e.query2)==null?void 0:P.filter},groupSortPreference:f.map(v=>v==null?void 0:v.value),limit:a},...x},...e==null?void 0:e.query2,searchQuery:o,userTimeZone:s,filter:{filters:d,operator:"and"}}}return this.fetch({endpoint:"queryCollection",body:{collection:{id:r},collectionView:{id:n},loader:c},gotOptions:p})}async getUsers(r,n){return this.fetch({endpoint:"getRecordValues",body:{requests:r.map(e=>({id:e,table:"notion_user"}))},gotOptions:n})}async getBlocks(r,n){return this.fetch({endpoint:"syncRecordValues",body:{requests:r.map(e=>({table:"block",id:e,version:-1}))},gotOptions:n})}async getSignedFileUrls(r,n){return this.fetch({endpoint:"getSignedFileUrls",body:{urls:r},gotOptions:n})}async search(r,n){let e={type:"BlocksInAncestor",source:"quick_find_public",ancestorId:$(r.ancestorId),sort:{field: "relevance"},limit:r.limit||20,query:r.query,filters:{isDeletedOnly:!1,isNavigableOnly:!1,excludeTemplates:!0,requireEditPermissions:!1,ancestors:[],createdBy:[],editedBy:[],lastEditedTime:{},createdTime:{},...r.filters}};return this.fetch({endpoint:"search",body:e,gotOptions:n})}async fetch({endpoint:r,body:n,gotOptions:e,headers:a}){let o={...a,...e==null?void 0:e.headers,"Content-Type":"application/json"};this._authToken&&(o.cookie=`token_v2=${this._authToken}`),this._activeUser&&(o["x-notion-active-user-header"]=this._activeUser);let s=`${this._apiBaseUrl}/${r}`;return z.post(s,{...e,json:n,headers:o}).json()}};export{E as NotionAPI};
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/notion-client/build/index.js.map b/node_modules/notion-client/build/index.js.map
index a8a38c6..0920514 100644
--- a/node_modules/notion-client/build/index.js.map
+++ b/node_modules/notion-client/build/index.js.map
@@ -1 +1 @@
-{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\nimport * as notion from 'notion-types'\nimport got, { OptionsOfJSONResponseBody } from 'got'\nimport {\n  getBlockCollectionId,\n  getPageContentBlockIds,\n  parsePageId,\n  uuidToId\n} from 'notion-utils'\nimport pMap from 'p-map'\n\nimport * as types from './types'\n\n/**\n * Main Notion API client.\n */\nexport class NotionAPI {\n  private readonly _apiBaseUrl: string\n  private readonly _authToken?: string\n  private readonly _activeUser?: string\n  private readonly _userTimeZone: string\n\n  constructor({\n    apiBaseUrl = 'https://www.notion.so/api/v3',\n    authToken,\n    activeUser,\n    userTimeZone = 'America/New_York'\n  }: {\n    apiBaseUrl?: string\n    authToken?: string\n    userLocale?: string\n    userTimeZone?: string\n    activeUser?: string\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl\n    this._authToken = authToken\n    this._activeUser = activeUser\n    this._userTimeZone = userTimeZone\n  }\n\n  public async getPage(\n    pageId: string,\n    {\n      concurrency = 3,\n      fetchMissingBlocks = true,\n      fetchCollections = true,\n      signFileUrls = true,\n      chunkLimit = 100,\n      chunkNumber = 0,\n      gotOptions\n    }: {\n      concurrency?: number\n      fetchMissingBlocks?: boolean\n      fetchCollections?: boolean\n      signFileUrls?: boolean\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ): Promise<notion.ExtendedRecordMap> {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      gotOptions\n    })\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\n\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\n    }\n\n    // ensure that all top-level maps exist\n    recordMap.collection = recordMap.collection ?? {}\n    recordMap.collection_view = recordMap.collection_view ?? {}\n    recordMap.notion_user = recordMap.notion_user ?? {}\n\n    // additional mappings added for convenience\n    // note: these are not native notion objects\n    recordMap.collection_query = {}\n    recordMap.signed_urls = {}\n\n    if (fetchMissingBlocks) {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // fetch any missing content blocks\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        )\n\n        if (!pendingBlockIds.length) {\n          break\n        }\n\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          gotOptions\n        ).then((res) => res.recordMap.block)\n\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      }\n    }\n\n    const contentBlockIds = getPageContentBlockIds(recordMap)\n\n    // Optionally fetch all data for embedded collections and their associated views.\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\n    // This is really convenient in order to ensure that all data needed for a given\n    // Notion page is readily available for use cases involving server-side rendering\n    // and edge caching.\n    if (fetchCollections) {\n      const allCollectionInstances: Array<{\n        collectionId: string\n        collectionViewId: string\n      }> = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId].value\n        const collectionId =\n          block &&\n          (block.type === 'collection_view' ||\n            block.type === 'collection_view_page') &&\n          getBlockCollectionId(block, recordMap)\n\n        if (collectionId) {\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId\n          }))\n        } else {\n          return []\n        }\n      })\n\n      // fetch data for all collection view instances\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId } = collectionInstance\n          const collectionView =\n            recordMap.collection_view[collectionViewId]?.value\n\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                gotOptions\n              }\n            )\n\n            // await fs.writeFile(\n            //   `${collectionId}-${collectionViewId}.json`,\n            //   JSON.stringify(collectionData.result, null, 2)\n            // )\n\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            }\n\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            }\n\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            }\n\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            }\n\n            recordMap.collection_query![collectionId] = {\n              ...recordMap.collection_query![collectionId],\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\n            }\n          } catch (err) {\n            // It's possible for public pages to link to private collections, in which case\n            // Notion returns a 400 error\n            console.warn('NotionAPI collectionQuery error', pageId, err.message)\n            console.error(err)\n          }\n        },\n        {\n          concurrency\n        }\n      )\n    }\n\n    // Optionally fetch signed URLs for any embedded files.\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\n    // because it is preferable for many use cases as opposed to making these API calls\n    // lazily from the client-side.\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, gotOptions })\n    }\n\n    return recordMap\n  }\n\n  public async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    gotOptions = {}\n  }: {\n    recordMap: notion.ExtendedRecordMap\n    contentBlockIds?: string[]\n    gotOptions?: OptionsOfJSONResponseBody\n  }) {\n    recordMap.signed_urls = {}\n\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap)\n    }\n\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (\n        block &&\n        (block.type === 'pdf' ||\n          block.type === 'audio' ||\n          (block.type === 'image' && block.file_ids?.length) ||\n          block.type === 'video' ||\n          block.type === 'file' ||\n          block.type === 'page')\n      ) {\n        const source =\n          block.type === 'page'\n            ? block.format?.page_cover\n            : block.properties?.source?.[0]?.[0]\n        // console.log(block, source)\n\n        if (source) {\n          if (!source.includes('secure.notion-static.com')) {\n            return []\n          }\n\n          return {\n            permissionRecord: {\n              table: 'block',\n              id: block.id\n            },\n            url: source\n          }\n        }\n      }\n\n      return []\n    })\n\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          gotOptions\n        )\n\n        if (signedUrls.length === allFileInstances.length) {\n          for (let i = 0; i < allFileInstances.length; ++i) {\n            const file = allFileInstances[i]\n            const signedUrl = signedUrls[i]\n\n            recordMap.signed_urls[file.permissionRecord.id] = signedUrl\n          }\n        }\n      } catch (err) {\n        console.warn('NotionAPI getSignedfileUrls error', err)\n      }\n    }\n  }\n\n  public async getPageRaw(\n    pageId: string,\n    {\n      gotOptions,\n      chunkLimit = 100,\n      chunkNumber = 0\n    }: {\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const parsedPageId = parsePageId(pageId)\n\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\n    }\n\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber: chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    }\n\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'loadPageChunk',\n      body,\n      gotOptions\n    })\n  }\n\n  public async getCollectionData(\n    collectionId: string,\n    collectionViewId: string,\n    collectionView: any,\n    {\n      limit = 9999,\n      searchQuery = '',\n      userTimeZone = this._userTimeZone,\n      loadContentCover = true,\n      gotOptions\n    }: {\n      type?: notion.CollectionViewType\n      limit?: number\n      searchQuery?: string\n      userTimeZone?: string\n      userLocale?: string\n      loadContentCover?: boolean\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const type = collectionView?.type\n    const isBoardType = type === 'board'\n    const groupBy = isBoardType\n      ? collectionView?.format?.board_columns_by\n      : collectionView?.format?.collection_group_by\n\n    let filters = []\n    if (collectionView?.format?.property_filters) {\n      filters = collectionView.format?.property_filters.map((filterObj) => {\n        //get the inner filter\n        return {\n          filter: filterObj?.filter?.filter,\n          property: filterObj?.filter?.property\n        }\n      })\n    }\n\n    //Fixes formula filters from not working\n    if (collectionView?.query2?.filter?.filters) {\n      filters.push(...collectionView.query2.filter.filters)\n    }\n\n    let loader: any = {\n      type: 'reducer',\n      reducers: {\n        collection_group_results: {\n          type: 'results',\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      filter: {\n        filters: filters,\n        operator: 'and'\n      },\n      searchQuery,\n      userTimeZone\n    }\n\n    if (groupBy) {\n      const groups =\n        collectionView?.format?.board_columns ||\n        collectionView?.format?.collection_groups ||\n        []\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\n      const operators = {\n        checkbox: 'checkbox_is',\n        url: 'string_starts_with',\n        text: 'string_starts_with',\n        select: 'enum_is',\n        multi_select: 'enum_contains',\n        created_time: 'date_is_within',\n        ['undefined']: 'is_empty'\n      }\n\n      const reducersQuery = {}\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type }\n        } = group\n\n        for (const iterator of iterators) {\n          const iteratorProps =\n            iterator === 'results'\n              ? {\n                  type: iterator,\n                  limit\n                }\n              : {\n                  type: 'aggregation',\n                  aggregation: {\n                    aggregator: 'count'\n                  }\n                }\n\n          const isUncategorizedValue = typeof value === 'undefined'\n          const isDateValue = value?.range\n          // TODO: review dates reducers\n          const queryLabel = isUncategorizedValue\n            ? 'uncategorized'\n            : isDateValue\n            ? value.range?.start_date || value.range?.end_date\n            : value?.value || value\n\n          const queryValue =\n            !isUncategorizedValue && (isDateValue || value?.value || value)\n\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: 'and',\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue\n                      ? operators[type]\n                      : 'is_empty',\n                    ...(!isUncategorizedValue && {\n                      value: {\n                        type: 'exact',\n                        value: queryValue\n                      }\n                    })\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\n      loader = {\n        type: 'reducer',\n        reducers: {\n          [reducerLabel]: {\n            type: 'groups',\n            groupBy,\n            ...(collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            }),\n            groupSortPreference: groups.map((group) => group?.value),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone,\n        //TODO: add filters here\n        filter: {\n          filters: filters,\n          operator: 'and'\n        }\n      }\n    }\n\n    // if (isBoardType) {\n    //   console.log(\n    //     JSON.stringify(\n    //       {\n    //         collectionId,\n    //         collectionViewId,\n    //         loader,\n    //         groupBy: groupBy || 'NONE',\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\n    //       },\n    //       null,\n    //       2\n    //     )\n    //   )\n    // }\n\n    return this.fetch<notion.CollectionInstance>({\n      endpoint: 'queryCollection',\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        loader\n      },\n      gotOptions\n    })\n  }\n\n  public async getUsers(\n    userIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.RecordValues<notion.User>>({\n      endpoint: 'getRecordValues',\n      body: {\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getBlocks(\n    blockIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'syncRecordValues',\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: 'block',\n          id: blockId,\n          version: -1\n        }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getSignedFileUrls(\n    urls: types.SignedUrlRequest[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<types.SignedUrlResponse>({\n      endpoint: 'getSignedFileUrls',\n      body: {\n        urls\n      },\n      gotOptions\n    })\n  }\n\n  public async search(\n    params: notion.SearchParams,\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    const body = {\n      type: 'BlocksInAncestor',\n      source: 'quick_find_public',\n      ancestorId: parsePageId(params.ancestorId),\n      sort: 'Relevance',\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    }\n\n    return this.fetch<notion.SearchResults>({\n      endpoint: 'search',\n      body,\n      gotOptions\n    })\n  }\n\n  public async fetch<T>({\n    endpoint,\n    body,\n    gotOptions,\n    headers: clientHeaders\n  }: {\n    endpoint: string\n    body: object\n    gotOptions?: OptionsOfJSONResponseBody\n    headers?: any\n  }): Promise<T> {\n    const headers: any = {\n      ...clientHeaders,\n      ...gotOptions?.headers,\n      'Content-Type': 'application/json'\n    }\n\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`\n    }\n\n    if (this._activeUser) {\n      headers['x-notion-active-user-header'] = this._activeUser\n    }\n\n    const url = `${this._apiBaseUrl}/${endpoint}`\n\n    return got\n      .post(url, {\n        ...gotOptions,\n        json: body,\n        headers\n      })\n      .json()\n\n    // return fetch(url, {\n    //   method: 'post',\n    //   body: JSON.stringify(body),\n    //   headers\n    // }).then((res) => {\n    //   console.log(endpoint, res)\n    //   return res.json()\n    // })\n  }\n}\n"],"mappings":"AAEA,OAAOA,MAAwC,MAC/C,OACE,wBAAAC,EACA,0BAAAC,EACA,eAAAC,EACA,YAAAC,MACK,eACP,OAAOC,MAAU,QAOV,IAAMC,EAAN,KAAgB,CAMrB,YAAY,CACV,WAAAC,EAAa,+BACb,UAAAC,EACA,WAAAC,EACA,aAAAC,EAAe,kBACjB,EAMI,CAAC,EAAG,CACN,KAAK,YAAcH,EACnB,KAAK,WAAaC,EAClB,KAAK,YAAcC,EACnB,KAAK,cAAgBC,CACvB,CAEA,MAAa,QACXC,EACA,CACE,YAAAC,EAAc,EACd,mBAAAC,EAAqB,GACrB,iBAAAC,EAAmB,GACnB,aAAAC,EAAe,GACf,WAAAC,EAAa,IACb,YAAAC,EAAc,EACd,WAAAC,CACF,EAQI,CAAC,EAC8B,CACnC,IAAMC,EAAO,MAAM,KAAK,WAAWR,EAAQ,CACzC,WAAAK,EACA,YAAAC,EACA,WAAAC,CACF,CAAC,EACKE,EAAYD,GAAA,YAAAA,EAAM,UAExB,GAAI,EAACC,GAAA,MAAAA,EAAW,OACd,MAAM,IAAI,MAAM,0BAA0BhB,EAASO,CAAM,IAAI,EAa/D,GATAS,EAAU,WAAaA,EAAU,YAAc,CAAC,EAChDA,EAAU,gBAAkBA,EAAU,iBAAmB,CAAC,EAC1DA,EAAU,YAAcA,EAAU,aAAe,CAAC,EAIlDA,EAAU,iBAAmB,CAAC,EAC9BA,EAAU,YAAc,CAAC,EAErBP,EAEF,OAAa,CAEX,IAAMQ,EAAkBnB,EAAuBkB,CAAS,EAAE,OACvDE,GAAO,CAACF,EAAU,MAAME,EAC3B,EAEA,GAAI,CAACD,EAAgB,OACnB,MAGF,IAAME,EAAY,MAAM,KAAK,UAC3BF,EACAH,CACF,EAAE,KAAMM,GAAQA,EAAI,UAAU,KAAK,EAEnCJ,EAAU,MAAQ,CAAE,GAAGA,EAAU,MAAO,GAAGG,CAAU,CACvD,CAGF,IAAME,EAAkBvB,EAAuBkB,CAAS,EAOxD,GAAIN,EAAkB,CACpB,IAAMY,EAGDD,EAAgB,QAASE,GAAY,CAjHhD,IAAAC,EAkHQ,IAAMC,EAAQT,EAAU,MAAMO,GAAS,MACjCG,EACJD,IACCA,EAAM,OAAS,mBACdA,EAAM,OAAS,yBACjB5B,EAAqB4B,EAAOT,CAAS,EAEvC,OAAIU,GACKF,EAAAC,EAAM,WAAN,YAAAD,EAAgB,IAAKG,IAAsB,CAChD,aAAAD,EACA,iBAAAC,CACF,IAEO,CAAC,CAEZ,CAAC,EAGD,MAAM1B,EACJqB,EACA,MAAOM,GAAuB,CAtItC,IAAAJ,EAAAK,EAuIU,GAAM,CAAE,aAAAH,EAAc,iBAAAC,CAAiB,EAAIC,EACrCE,GACJN,EAAAR,EAAU,gBAAgBW,KAA1B,YAAAH,EAA6C,MAE/C,GAAI,CACF,IAAMO,EAAiB,MAAM,KAAK,kBAChCL,EACAC,EACAG,EACA,CACE,WAAAhB,CACF,CACF,EAOAE,EAAU,MAAQ,CAChB,GAAGA,EAAU,MACb,GAAGe,EAAe,UAAU,KAC9B,EAEAf,EAAU,WAAa,CACrB,GAAGA,EAAU,WACb,GAAGe,EAAe,UAAU,UAC9B,EAEAf,EAAU,gBAAkB,CAC1B,GAAGA,EAAU,gBACb,GAAGe,EAAe,UAAU,eAC9B,EAEAf,EAAU,YAAc,CACtB,GAAGA,EAAU,YACb,GAAGe,EAAe,UAAU,WAC9B,EAEAf,EAAU,iBAAkBU,GAAgB,CAC1C,GAAGV,EAAU,iBAAkBU,GAC/B,CAACC,IAAoBE,EAAAE,EAAe,SAAf,YAAAF,EAA+B,cACtD,CACF,OAASG,EAAP,CAGA,QAAQ,KAAK,kCAAmCzB,EAAQyB,EAAI,OAAO,EACnE,QAAQ,MAAMA,CAAG,CACnB,CACF,EACA,CACE,YAAAxB,CACF,CACF,CACF,CAMA,OAAIG,GACF,MAAM,KAAK,cAAc,CAAE,UAAAK,EAAW,gBAAAK,EAAiB,WAAAP,CAAW,CAAC,EAG9DE,CACT,CAEA,MAAa,cAAc,CACzB,UAAAA,EACA,gBAAAK,EACA,WAAAP,EAAa,CAAC,CAChB,EAIG,CACDE,EAAU,YAAc,CAAC,EAEpBK,IACHA,EAAkBvB,EAAuBkB,CAAS,GAGpD,IAAMiB,EAAmBZ,EAAgB,QAASE,GAAY,CAzNlE,IAAAC,EAAAK,EAAAK,EAAAC,EAAAC,EAAAC,EA0NM,IAAMZ,GAAQD,EAAAR,EAAU,MAAMO,KAAhB,YAAAC,EAA0B,MAExC,GACEC,IACCA,EAAM,OAAS,OACdA,EAAM,OAAS,SACdA,EAAM,OAAS,WAAWI,EAAAJ,EAAM,WAAN,YAAAI,EAAgB,SAC3CJ,EAAM,OAAS,SACfA,EAAM,OAAS,QACfA,EAAM,OAAS,QACjB,CACA,IAAMa,EACJb,EAAM,OAAS,QACXS,EAAAT,EAAM,SAAN,YAAAS,EAAc,YACdG,GAAAD,GAAAD,EAAAV,EAAM,aAAN,YAAAU,EAAkB,SAAlB,YAAAC,EAA2B,KAA3B,YAAAC,EAAgC,GAGtC,GAAIC,EACF,OAAKA,EAAO,SAAS,0BAA0B,EAIxC,CACL,iBAAkB,CAChB,MAAO,QACP,GAAIb,EAAM,EACZ,EACA,IAAKa,CACP,EATS,CAAC,CAWd,CAEA,MAAO,CAAC,CACV,CAAC,EAED,GAAIL,EAAiB,OAAS,EAC5B,GAAI,CACF,GAAM,CAAE,WAAAM,CAAW,EAAI,MAAM,KAAK,kBAChCN,EACAnB,CACF,EAEA,GAAIyB,EAAW,SAAWN,EAAiB,OACzC,QAASO,EAAI,EAAGA,EAAIP,EAAiB,OAAQ,EAAEO,EAAG,CAChD,IAAMC,EAAOR,EAAiBO,GACxBE,EAAYH,EAAWC,GAE7BxB,EAAU,YAAYyB,EAAK,iBAAiB,IAAMC,CACpD,CAEJ,OAASV,EAAP,CACA,QAAQ,KAAK,oCAAqCA,CAAG,CACvD,CAEJ,CAEA,MAAa,WACXzB,EACA,CACE,WAAAO,EACA,WAAAF,EAAa,IACb,YAAAC,EAAc,CAChB,EAII,CAAC,EACL,CACA,IAAM8B,EAAe5C,EAAYQ,CAAM,EAEvC,GAAI,CAACoC,EACH,MAAM,IAAI,MAAM,0BAA0BpC,IAAS,EAGrD,IAAMqC,EAAO,CACX,OAAQD,EACR,MAAO/B,EACP,YAAaC,EACb,OAAQ,CAAE,MAAO,CAAC,CAAE,EACpB,gBAAiB,EACnB,EAEA,OAAO,KAAK,MAAwB,CAClC,SAAU,gBACV,KAAA+B,EACA,WAAA9B,CACF,CAAC,CACH,CAEA,MAAa,kBACXY,EACAC,EACAG,EACA,CACE,MAAAe,EAAQ,KACR,YAAAC,EAAc,GACd,aAAAxC,EAAe,KAAK,cACpB,iBAAAyC,EAAmB,GACnB,WAAAjC,CACF,EAQI,CAAC,EACL,CAtUJ,IAAAU,EAAAK,EAAAK,EAAAC,EAAAC,EAAAC,EAAAW,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAuUI,IAAMC,EAAOxB,GAAA,YAAAA,EAAgB,KACvByB,EAAcD,IAAS,QACvBE,EAAUD,GACZ/B,EAAAM,GAAA,YAAAA,EAAgB,SAAhB,YAAAN,EAAwB,kBACxBK,EAAAC,GAAA,YAAAA,EAAgB,SAAhB,YAAAD,EAAwB,oBAExB4B,EAAU,CAAC,GACXvB,EAAAJ,GAAA,YAAAA,EAAgB,SAAhB,MAAAI,EAAwB,mBAC1BuB,GAAUtB,EAAAL,EAAe,SAAf,YAAAK,EAAuB,iBAAiB,IAAKuB,GAAc,CA/U3E,IAAAlC,EAAAK,EAiVQ,MAAO,CACL,QAAQL,EAAAkC,GAAA,YAAAA,EAAW,SAAX,YAAAlC,EAAmB,OAC3B,UAAUK,EAAA6B,GAAA,YAAAA,EAAW,SAAX,YAAA7B,EAAmB,QAC/B,CACF,KAIEQ,GAAAD,EAAAN,GAAA,YAAAA,EAAgB,SAAhB,YAAAM,EAAwB,SAAxB,MAAAC,EAAgC,SAClCoB,EAAQ,KAAK,GAAG3B,EAAe,OAAO,OAAO,OAAO,EAGtD,IAAI6B,EAAc,CAChB,KAAM,UACN,SAAU,CACR,yBAA0B,CACxB,KAAM,UACN,MAAAd,EACA,iBAAAE,CACF,CACF,EACA,KAAM,CAAC,EACP,GAAGjB,GAAA,YAAAA,EAAgB,OACnB,OAAQ,CACN,QAAS2B,EACT,SAAU,KACZ,EACA,YAAAX,EACA,aAAAxC,CACF,EAEA,GAAIkD,EAAS,CACX,IAAMI,IACJZ,EAAAlB,GAAA,YAAAA,EAAgB,SAAhB,YAAAkB,EAAwB,kBACxBC,EAAAnB,GAAA,YAAAA,EAAgB,SAAhB,YAAAmB,EAAwB,oBACxB,CAAC,EACGY,EAAY,CAACN,EAAc,QAAU,oBAAqB,SAAS,EACnEO,EAAY,CAChB,SAAU,cACV,IAAK,qBACL,KAAM,qBACN,OAAQ,UACR,aAAc,gBACd,aAAc,iBACb,UAAc,UACjB,EAEMC,EAAgB,CAAC,EACvB,QAAWC,KAASJ,EAAQ,CAC1B,GAAM,CACJ,SAAAK,EACA,MAAO,CAAE,MAAAC,EAAO,KAAAZ,CAAK,CACvB,EAAIU,EAEJ,QAAWG,KAAYN,EAAW,CAChC,IAAMO,EACJD,IAAa,UACT,CACE,KAAMA,EACN,MAAAtB,CACF,EACA,CACE,KAAM,cACN,YAAa,CACX,WAAY,OACd,CACF,EAEAwB,EAAuB,OAAOH,EAAU,IACxCI,EAAcJ,GAAA,YAAAA,EAAO,MAErBK,EAAaF,EACf,gBACAC,IACApB,EAAAgB,EAAM,QAAN,YAAAhB,EAAa,eAAcC,EAAAe,EAAM,QAAN,YAAAf,EAAa,WACxCe,GAAA,YAAAA,EAAO,QAASA,EAEdM,EACJ,CAACH,IAAyBC,IAAeJ,GAAA,YAAAA,EAAO,QAASA,GAE3DH,EAAc,GAAGI,KAAYb,KAAQiB,KAAgB,CACnD,GAAGH,EACH,OAAQ,CACN,SAAU,MACV,QAAS,CACP,CACE,SAAAH,EACA,OAAQ,CACN,SAAWI,EAEP,WADAP,EAAUR,GAEd,GAAI,CAACe,GAAwB,CAC3B,MAAO,CACL,KAAM,QACN,MAAOG,CACT,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CAEA,IAAMC,EAAelB,EAAc,gBAAkB,GAAGD,WACxDK,EAAS,CACP,KAAM,UACN,SAAU,CACR,CAACc,GAAe,CACd,KAAM,SACN,QAAAjB,EACA,KAAIJ,EAAAtB,GAAA,YAAAA,EAAgB,SAAhB,YAAAsB,EAAwB,SAAU,CACpC,QAAQC,EAAAvB,GAAA,YAAAA,EAAgB,SAAhB,YAAAuB,EAAwB,MAClC,EACA,oBAAqBO,EAAO,IAAKI,GAAUA,GAAA,YAAAA,EAAO,KAAK,EACvD,MAAAnB,CACF,EACA,GAAGkB,CACL,EACA,GAAGjC,GAAA,YAAAA,EAAgB,OACnB,YAAAgB,EACA,aAAAxC,EAEA,OAAQ,CACN,QAASmD,EACT,SAAU,KACZ,CACF,CACF,CAkBA,OAAO,KAAK,MAAiC,CAC3C,SAAU,kBACV,KAAM,CACJ,WAAY,CACV,GAAI/B,CACN,EACA,eAAgB,CACd,GAAIC,CACN,EACA,OAAAgC,CACF,EACA,WAAA7C,CACF,CAAC,CACH,CAEA,MAAa,SACX4D,EACA5D,EACA,CACA,OAAO,KAAK,MAAwC,CAClD,SAAU,kBACV,KAAM,CACJ,SAAU4D,EAAQ,IAAKxD,IAAQ,CAAE,GAAAA,EAAI,MAAO,aAAc,EAAE,CAC9D,EACA,WAAAJ,CACF,CAAC,CACH,CAEA,MAAa,UACX6D,EACA7D,EACA,CACA,OAAO,KAAK,MAAwB,CAClC,SAAU,mBACV,KAAM,CACJ,SAAU6D,EAAS,IAAKpD,IAAa,CAEnC,MAAO,QACP,GAAIA,EACJ,QAAS,EACX,EAAE,CACJ,EACA,WAAAT,CACF,CAAC,CACH,CAEA,MAAa,kBACX8D,EACA9D,EACA,CACA,OAAO,KAAK,MAA+B,CACzC,SAAU,oBACV,KAAM,CACJ,KAAA8D,CACF,EACA,WAAA9D,CACF,CAAC,CACH,CAEA,MAAa,OACX+D,EACA/D,EACA,CACA,IAAM8B,EAAO,CACX,KAAM,mBACN,OAAQ,oBACR,WAAY7C,EAAY8E,EAAO,UAAU,EACzC,KAAM,YACN,MAAOA,EAAO,OAAS,GACvB,MAAOA,EAAO,MACd,QAAS,CACP,cAAe,GACf,gBAAiB,GACjB,iBAAkB,GAClB,uBAAwB,GACxB,UAAW,CAAC,EACZ,UAAW,CAAC,EACZ,SAAU,CAAC,EACX,eAAgB,CAAC,EACjB,YAAa,CAAC,EACd,GAAGA,EAAO,OACZ,CACF,EAEA,OAAO,KAAK,MAA4B,CACtC,SAAU,SACV,KAAAjC,EACA,WAAA9B,CACF,CAAC,CACH,CAEA,MAAa,MAAS,CACpB,SAAAgE,EACA,KAAAlC,EACA,WAAA9B,EACA,QAASiE,CACX,EAKe,CACb,IAAMC,EAAe,CACnB,GAAGD,EACH,GAAGjE,GAAA,YAAAA,EAAY,QACf,eAAgB,kBAClB,EAEI,KAAK,aACPkE,EAAQ,OAAS,YAAY,KAAK,cAGhC,KAAK,cACPA,EAAQ,+BAAiC,KAAK,aAGhD,IAAMC,EAAM,GAAG,KAAK,eAAeH,IAEnC,OAAOlF,EACJ,KAAKqF,EAAK,CACT,GAAGnE,EACH,KAAM8B,EACN,QAAAoC,CACF,CAAC,EACA,KAAK,CAUV,CACF","names":["got","getBlockCollectionId","getPageContentBlockIds","parsePageId","uuidToId","pMap","NotionAPI","apiBaseUrl","authToken","activeUser","userTimeZone","pageId","concurrency","fetchMissingBlocks","fetchCollections","signFileUrls","chunkLimit","chunkNumber","gotOptions","page","recordMap","pendingBlockIds","id","newBlocks","res","contentBlockIds","allCollectionInstances","blockId","_a","block","collectionId","collectionViewId","collectionInstance","_b","collectionView","collectionData","err","allFileInstances","_c","_d","_e","_f","source","signedUrls","i","file","signedUrl","parsedPageId","body","limit","searchQuery","loadContentCover","_g","_h","_i","_j","_k","_l","type","isBoardType","groupBy","filters","filterObj","loader","groups","iterators","operators","reducersQuery","group","property","value","iterator","iteratorProps","isUncategorizedValue","isDateValue","queryLabel","queryValue","reducerLabel","userIds","blockIds","urls","params","endpoint","clientHeaders","headers","url"]}
\ No newline at end of file
+{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\nimport * as notion from 'notion-types'\nimport got, { OptionsOfJSONResponseBody } from 'got'\nimport {\n  getBlockCollectionId,\n  getPageContentBlockIds,\n  parsePageId,\n  uuidToId\n} from 'notion-utils'\nimport pMap from 'p-map'\n\nimport * as types from './types'\n\n/**\n * Main Notion API client.\n */\nexport class NotionAPI {\n  private readonly _apiBaseUrl: string\n  private readonly _authToken?: string\n  private readonly _activeUser?: string\n  private readonly _userTimeZone: string\n\n  constructor({\n    apiBaseUrl = 'https://www.notion.so/api/v3',\n    authToken,\n    activeUser,\n    userTimeZone = 'America/New_York'\n  }: {\n    apiBaseUrl?: string\n    authToken?: string\n    userLocale?: string\n    userTimeZone?: string\n    activeUser?: string\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl\n    this._authToken = authToken\n    this._activeUser = activeUser\n    this._userTimeZone = userTimeZone\n  }\n\n  public async getPage(\n    pageId: string,\n    {\n      concurrency = 3,\n      fetchMissingBlocks = true,\n      fetchCollections = true,\n      signFileUrls = true,\n      chunkLimit = 100,\n      chunkNumber = 0,\n      gotOptions\n    }: {\n      concurrency?: number\n      fetchMissingBlocks?: boolean\n      fetchCollections?: boolean\n      signFileUrls?: boolean\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ): Promise<notion.ExtendedRecordMap> {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      gotOptions\n    })\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\n\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\n    }\n\n    // ensure that all top-level maps exist\n    recordMap.collection = recordMap.collection ?? {}\n    recordMap.collection_view = recordMap.collection_view ?? {}\n    recordMap.notion_user = recordMap.notion_user ?? {}\n\n    // additional mappings added for convenience\n    // note: these are not native notion objects\n    recordMap.collection_query = {}\n    recordMap.signed_urls = {}\n\n    if (fetchMissingBlocks) {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // fetch any missing content blocks\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        )\n\n        if (!pendingBlockIds.length) {\n          break\n        }\n\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          gotOptions\n        ).then((res) => res.recordMap.block)\n\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      }\n    }\n\n    const contentBlockIds = getPageContentBlockIds(recordMap)\n\n    // Optionally fetch all data for embedded collections and their associated views.\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\n    // This is really convenient in order to ensure that all data needed for a given\n    // Notion page is readily available for use cases involving server-side rendering\n    // and edge caching.\n    if (fetchCollections) {\n      const allCollectionInstances: Array<{\n        collectionId: string\n        collectionViewId: string\n      }> = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId].value\n        const collectionId =\n          block &&\n          (block.type === 'collection_view' ||\n            block.type === 'collection_view_page') &&\n          getBlockCollectionId(block, recordMap)\n\n        if (collectionId) {\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId\n          }))\n        } else {\n          return []\n        }\n      })\n\n      // fetch data for all collection view instances\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId } = collectionInstance\n          const collectionView =\n            recordMap.collection_view[collectionViewId]?.value\n\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                gotOptions\n              }\n            )\n\n            // await fs.writeFile(\n            //   `${collectionId}-${collectionViewId}.json`,\n            //   JSON.stringify(collectionData.result, null, 2)\n            // )\n\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            }\n\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            }\n\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            }\n\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            }\n\n            recordMap.collection_query![collectionId] = {\n              ...recordMap.collection_query![collectionId],\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\n            }\n          } catch (err) {\n            // It's possible for public pages to link to private collections, in which case\n            // Notion returns a 400 error\n            console.warn('NotionAPI collectionQuery error', pageId, err.message)\n            console.error(err)\n          }\n        },\n        {\n          concurrency\n        }\n      )\n    }\n\n    // Optionally fetch signed URLs for any embedded files.\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\n    // because it is preferable for many use cases as opposed to making these API calls\n    // lazily from the client-side.\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, gotOptions })\n    }\n\n    return recordMap\n  }\n\n  public async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    gotOptions = {}\n  }: {\n    recordMap: notion.ExtendedRecordMap\n    contentBlockIds?: string[]\n    gotOptions?: OptionsOfJSONResponseBody\n  }) {\n    recordMap.signed_urls = {}\n\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap)\n    }\n\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (\n        block &&\n        (block.type === 'pdf' ||\n          block.type === 'audio' ||\n          (block.type === 'image' && block.file_ids?.length) ||\n          block.type === 'video' ||\n          block.type === 'file' ||\n          block.type === 'page')\n      ) {\n        const source =\n          block.type === 'page'\n            ? block.format?.page_cover\n            : block.properties?.source?.[0]?.[0]\n        // console.log(block, source)\n\n        if (source) {\n          if (!source.includes('secure.notion-static.com')) {\n            return []\n          }\n\n          return {\n            permissionRecord: {\n              table: 'block',\n              id: block.id\n            },\n            url: source\n          }\n        }\n      }\n\n      return []\n    })\n\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          gotOptions\n        )\n\n        if (signedUrls.length === allFileInstances.length) {\n          for (let i = 0; i < allFileInstances.length; ++i) {\n            const file = allFileInstances[i]\n            const signedUrl = signedUrls[i]\n\n            recordMap.signed_urls[file.permissionRecord.id] = signedUrl\n          }\n        }\n      } catch (err) {\n        console.warn('NotionAPI getSignedfileUrls error', err)\n      }\n    }\n  }\n\n  public async getPageRaw(\n    pageId: string,\n    {\n      gotOptions,\n      chunkLimit = 100,\n      chunkNumber = 0\n    }: {\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const parsedPageId = parsePageId(pageId)\n\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\n    }\n\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber: chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    }\n\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'loadPageChunk',\n      body,\n      gotOptions\n    })\n  }\n\n  public async getCollectionData(\n    collectionId: string,\n    collectionViewId: string,\n    collectionView: any,\n    {\n      limit = 9999,\n      searchQuery = '',\n      userTimeZone = this._userTimeZone,\n      loadContentCover = true,\n      gotOptions\n    }: {\n      type?: notion.CollectionViewType\n      limit?: number\n      searchQuery?: string\n      userTimeZone?: string\n      userLocale?: string\n      loadContentCover?: boolean\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const type = collectionView?.type\n    const isBoardType = type === 'board'\n    const groupBy = isBoardType\n      ? collectionView?.format?.board_columns_by\n      : collectionView?.format?.collection_group_by\n\n    let filters = []\n    if (collectionView?.format?.property_filters) {\n      filters = collectionView.format?.property_filters.map((filterObj) => {\n        //get the inner filter\n        return {\n          filter: filterObj?.filter?.filter,\n          property: filterObj?.filter?.property\n        }\n      })\n    }\n\n    //Fixes formula filters from not working\n    if (collectionView?.query2?.filter?.filters) {\n      filters.push(...collectionView.query2.filter.filters)\n    }\n\n    let loader: any = {\n      type: 'reducer',\n      reducers: {\n        collection_group_results: {\n          type: 'results',\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      filter: {\n        filters: filters,\n        operator: 'and'\n      },\n      searchQuery,\n      userTimeZone\n    }\n\n    if (groupBy) {\n      const groups =\n        collectionView?.format?.board_columns ||\n        collectionView?.format?.collection_groups ||\n        []\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\n      const operators = {\n        checkbox: 'checkbox_is',\n        url: 'string_starts_with',\n        text: 'string_starts_with',\n        select: 'enum_is',\n        multi_select: 'enum_contains',\n        created_time: 'date_is_within',\n        ['undefined']: 'is_empty'\n      }\n\n      const reducersQuery = {}\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type }\n        } = group\n\n        for (const iterator of iterators) {\n          const iteratorProps =\n            iterator === 'results'\n              ? {\n                  type: iterator,\n                  limit\n                }\n              : {\n                  type: 'aggregation',\n                  aggregation: {\n                    aggregator: 'count'\n                  }\n                }\n\n          const isUncategorizedValue = typeof value === 'undefined'\n          const isDateValue = value?.range\n          // TODO: review dates reducers\n          const queryLabel = isUncategorizedValue\n            ? 'uncategorized'\n            : isDateValue\n            ? value.range?.start_date || value.range?.end_date\n            : value?.value || value\n\n          const queryValue =\n            !isUncategorizedValue && (isDateValue || value?.value || value)\n\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: 'and',\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue\n                      ? operators[type]\n                      : 'is_empty',\n                    ...(!isUncategorizedValue && {\n                      value: {\n                        type: 'exact',\n                        value: queryValue\n                      }\n                    })\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\n      loader = {\n        type: 'reducer',\n        reducers: {\n          [reducerLabel]: {\n            type: 'groups',\n            groupBy,\n            ...(collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            }),\n            groupSortPreference: groups.map((group) => group?.value),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone,\n        //TODO: add filters here\n        filter: {\n          filters: filters,\n          operator: 'and'\n        }\n      }\n    }\n\n    // if (isBoardType) {\n    //   console.log(\n    //     JSON.stringify(\n    //       {\n    //         collectionId,\n    //         collectionViewId,\n    //         loader,\n    //         groupBy: groupBy || 'NONE',\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\n    //       },\n    //       null,\n    //       2\n    //     )\n    //   )\n    // }\n\n    return this.fetch<notion.CollectionInstance>({\n      endpoint: 'queryCollection',\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        loader\n      },\n      gotOptions\n    })\n  }\n\n  public async getUsers(\n    userIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.RecordValues<notion.User>>({\n      endpoint: 'getRecordValues',\n      body: {\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getBlocks(\n    blockIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'syncRecordValues',\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: 'block',\n          id: blockId,\n          version: -1\n        }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getSignedFileUrls(\n    urls: types.SignedUrlRequest[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<types.SignedUrlResponse>({\n      endpoint: 'getSignedFileUrls',\n      body: {\n        urls\n      },\n      gotOptions\n    })\n  }\n\n  public async search(\n    params: notion.SearchParams,\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    const body = {\n      type: 'BlocksInAncestor',\n      source: 'quick_find_public',\n      ancestorId: parsePageId(params.ancestorId),\n      sort: {field: 'relevance'},\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    }\n\n    return this.fetch<notion.SearchResults>({\n      endpoint: 'search',\n      body,\n      gotOptions\n    })\n  }\n\n  public async fetch<T>({\n    endpoint,\n    body,\n    gotOptions,\n    headers: clientHeaders\n  }: {\n    endpoint: string\n    body: object\n    gotOptions?: OptionsOfJSONResponseBody\n    headers?: any\n  }): Promise<T> {\n    const headers: any = {\n      ...clientHeaders,\n      ...gotOptions?.headers,\n      'Content-Type': 'application/json'\n    }\n\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`\n    }\n\n    if (this._activeUser) {\n      headers['x-notion-active-user-header'] = this._activeUser\n    }\n\n    const url = `${this._apiBaseUrl}/${endpoint}`\n\n    return got\n      .post(url, {\n        ...gotOptions,\n        json: body,\n        headers\n      })\n      .json()\n\n    // return fetch(url, {\n    //   method: 'post',\n    //   body: JSON.stringify(body),\n    //   headers\n    // }).then((res) => {\n    //   console.log(endpoint, res)\n    //   return res.json()\n    // })\n  }\n}\n"],"mappings":"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","names":["got","getBlockCollectionId","getPageContentBlockIds","parsePageId","uuidToId","pMap","NotionAPI","apiBaseUrl","authToken","activeUser","userTimeZone","pageId","concurrency","fetchMissingBlocks","fetchCollections","signFileUrls","chunkLimit","chunkNumber","gotOptions","page","recordMap","pendingBlockIds","id","newBlocks","res","contentBlockIds","allCollectionInstances","blockId","_a","block","collectionId","collectionViewId","collectionInstance","_b","collectionView","collectionData","err","allFileInstances","_c","_d","_e","_f","source","signedUrls","i","file","signedUrl","parsedPageId","body","limit","searchQuery","loadContentCover","_g","_h","_i","_j","_k","_l","type","isBoardType","groupBy","filters","filterObj","loader","groups","iterators","operators","reducersQuery","group","property","value","iterator","iteratorProps","isUncategorizedValue","isDateValue","queryLabel","queryValue","reducerLabel","userIds","blockIds","urls","params","endpoint","clientHeaders","headers","url"]}
\ No newline at end of file
